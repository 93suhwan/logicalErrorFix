// Generated by powerful Codeforces Tool
// You can download the binary file in here
// https://github.com/dianhsu/cf-tool/releases/ (Windows, macOS(x86, arm64),
// Linux) Author: xudian Time: 2021-12-17 16:34:23
//

#include <bits/stdc++.h>

#include <algorithm>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> PII;
typedef pair<ll, ll> PLL;
#define itr(...) begin(__VA_ARGS__), end(__VA_ARGS__)
#define fastIO() \
    ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr)
#define debug(x...)                       \
    do {                                    \
        cout << "\033[32;1m" << #x << " -> "; \
        rd_debug(x);                          \
    } while (0)
void rd_debug() { cout << "\033[39;0m" << endl; }
template <class T, class... Ts>
void rd_debug(const T& arg, const Ts&... args) {
    cout << arg << " ";
    rd_debug(args...);
}
#define pb push_back
#define PF(x) ((x) * (x))
#define LF(x) ((x)*PF(x))
#define fu(i, mm, MM) for (int(i) = (mm); (i) <= (MM); ++(i))
#define fd(i, MM, mm) for (int(i) = (MM); (i) >= (mm); --(i))
#define eps 1e-6

template <typename T = int>
inline T fRead() {
    T x = 0, w = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') w = -1;
        c = getchar();
    }
    while (c <= '9' && c >= '0') {
        x = (x << 1) + (x << 3) + c - '0';
        c = getchar();
    }
    return w == 1 ? x : -x;
}
template <typename T = int>
inline T cRead() {
    T ret;
    cin >> ret;
    return ret;
}

template <class T>
class Y {
    T f;

    public:
    template <class U>
        explicit Y(U&& f) : f(forward<U>(f)) {}
    template <class... Args>
        decltype(auto) operator()(Args&&... args) {
            return f(ref(*this), forward<Args>(args)...);
        }
};
template <class T>
Y(T) -> Y<T>;

const int MOD = 1e9 + 7;
const int inf = 0x3f3f3f3f;
const ll infl = 0x3f3f3f3f3f3f3f3fll;

struct Vertex {
    int x, y, c;
};

struct Cmp1 {
    bool operator()(const Vertex& arg1, const Vertex& arg2) {
        return (arg1.x == arg2.x ? arg1.y < arg2.y : arg1.x < arg2.x);
    }
};
struct Cmp2 {
    bool operator()(const Vertex& arg1, const Vertex& arg2) {
        return (arg1.y == arg2.y ? arg1.x < arg2.x : arg1.y < arg2.y);
    }
};
int main(int argc, char* argv[]) {
    fastIO();
    int n;
    cin >> n;
    vector<Vertex> arr, brr;
    for (int i = 1; i <= n; ++i) {
        int x, y, c;
        cin >> x >> y >> c;
        arr.push_back({x, y, c});
        brr.push_back({x, y, c});
    }
    auto&& x_axis = [&](const array<int, 3>& idx, int cnt) -> bool {
        int a = cnt, b = cnt, c = cnt;
        for (auto& it : arr) {
            if (a > 0) {
                if (it.c == idx[0]) --a;
            } else if (b > 0) {
                if (it.c == idx[1]) --b;
            } else if (c > 0) {
                if (it.c == idx[2]) --c;
            } else
                break;
        }
        return c <= 0;
    };
    auto&& lx_axis = [&](const array<int, 3>& idx, int cnt) -> bool {
        int lx = -inf, dy = -inf;
        int a = cnt, b = cnt, c = cnt;
        for (auto& it : arr) {
            if (it.c == idx[0]) {
                lx = max(lx, it.x);
                if (--a <= 0) break;
            }
        }
        if (a > 0) return false;
        for (auto& it : brr) {
            if (it.c == idx[1] and it.x > lx) {
                dy = max(dy, it.y);
                if (--b <= 0) break;
            }
        }
        if (b > 0) return false;
        for (auto& it : arr) {
            if (it.c == idx[2] and it.x > lx and it.y > dy) {
                if (--c <= 0) break;
            }
        }
        return c <= 0;
    };
    auto&& dy_axis = [&](const array<int, 3>& idx, int cnt) -> bool{
        int lx = -inf, dy = -inf;
        int a = cnt, b = cnt, c = cnt;
        for(auto& it: brr){
            if(it.c == idx[0]){
                dy = max(dy, it.y);
                if(--a <= 0) break;
            }
        }
        if(a > 0) return false;
        for(auto& it: arr){
            if(it.c == idx[1] and it.y > dy){
                lx = max(lx, it.x);
                if(--b <= 0) break;
            }
        }
        if(b > 0) return false;
        for(auto& it: arr){
            if(it.c == idx[2] and it.x > lx and it.y > dy){
                if(--c <= 0) break;
            }
        }
        return c <= 0;
    };
    auto&& handle = [&](const array<int, 3>& idx, int cnt) -> bool {
        if (x_axis(idx, cnt)) return true;
        if (lx_axis(idx, cnt)) return true;
        if (dy_axis(idx, cnt)) return true;
        return false;
    };
    vector<array<int, 3>> idxs{ {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2}, {3, 2, 1}};
    auto&& check = [&](int cnt) -> bool {
        for(auto& idx: idxs){
            if(handle(idx, cnt)) return true;
        }
        return false;
    };
    auto&& solve = [&]()->int{
        int ret = 1;
        for (int i = (1 << 20); i; i >>= 1) {
            if (ret + i <= n / 3 and check(ret + i)) {
                ret += i;
            }
        }
        return ret;
    };

    for(int i = 0; i < n; ++i){
        arr[i] = {arr[i].y, -arr[i].x, arr[i].c};
        brr[i] = {brr[i].y, -brr[i].x, brr[i].c};
    }
    sort(itr(arr), Cmp1());
    sort(itr(brr), Cmp2());
    int ans = solve();
    for(int i = 0; i < n; ++i){
        arr[i] = {arr[i].y, -arr[i].x, arr[i].c};
        brr[i] = {brr[i].y, -brr[i].x, brr[i].c};
    }
    sort(itr(arr), Cmp1());
    sort(itr(brr), Cmp2());
    ans = max(ans, solve());
    for(int i = 0; i < n; ++i){
        arr[i] = {arr[i].y, -arr[i].x, arr[i].c};
        brr[i] = {brr[i].y, -brr[i].x, brr[i].c};
    }
    sort(itr(arr), Cmp1());
    sort(itr(brr), Cmp2());
    ans = max(ans, solve());
    for(int i = 0; i < n; ++i){
        arr[i] = {arr[i].y, -arr[i].x, arr[i].c};
        brr[i] = {brr[i].y, -brr[i].x, brr[i].c};
    }
    sort(itr(arr), Cmp1());
    sort(itr(brr), Cmp2());
    ans = max(ans, solve());
    cout << ans * 3 << endl;
    return 0;
}
